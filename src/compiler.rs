use crate::parsing::Instruction;

use anyhow::{anyhow, Result};

use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;

macro_rules! write_tab {
    ($dst:expr, $($arg:tt)*) => {
        writeln!($dst, "\t{}", format!($($arg)*))
    };
}

fn generate_yasm_x86_64_linux_header(file: &mut File) -> Result<()> {
    writeln!(file, "; This file was generated by the Brainfuck compiler")?;
    writeln!(file, "; --- yasm-x86_64-compiler ---")?;
    writeln!(file, "; --- HEADER ---")?;
    writeln!(file, "extern exit")?;
    writeln!(file, "extern putchar")?;
    writeln!(file, "extern getchar")?;
    writeln!(file, "extern printf")?;
    writeln!(file, "segment .data")?;
    writeln!(
        file,
        "\tdebug_pointer: db 10, \"--- DEBUG ---\", 10, \"pointer: %ld\", 10, 0"
    )?;
    writeln!(
        file,
        "\tdebug_memory: db \"memory: %ld\", 10, \"--- DEBUG ---\", 10, 0"
    )?;
    writeln!(
        file,
        "overflow_message: db 27, \"[1;31mERROR: overflow exception\", 27, \"[0m\", 10, 0"
    )?;
    writeln!(
        file,
        "underflow_message: db 27, \"[1;31mERROR: underflow exception\", 27, \"[0m\", 10, 0"
    )?;
    write_tab!(file, "pointer: dd 15000")?;
    writeln!(file, "segment .bss")?;
    write_tab!(file, "array: resb 240000")?;
    writeln!(file, "segment .text")?;
    write_tab!(file, "global _start")?;
    writeln!(file, "_start:")?;
    Ok(())
}

fn generate_yasm_x86_64_linux_code(instructions: &[Instruction], file: &mut File) -> Result<()> {
    writeln!(file, "; --- BODY ---")?;
    for (index, instruction) in instructions.iter().enumerate() {
        writeln!(file, "addr_{index}:")?;
        match instruction {
            Instruction::IncrementPointer(value) => {
                write_tab!(file, "; --- Increment pointer ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "add ebx, {value} ; ebx += {value}")?;
                write_tab!(file, "mov [pointer], ebx ; pointer = ebx")?;
                write_tab!(file, "cmp ebx, 30000")?;
                write_tab!(file, "jge exception_overflow")?;
            }
            Instruction::DecrementPointer(value) => {
                write_tab!(file, "; --- Decrement pointer ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "sub ebx, {value} ; ebx -= {value}")?;
                write_tab!(file, "mov [pointer], ebx ; pointer = ebx")?;
                write_tab!(file, "cmp ebx, 0")?;
                write_tab!(file, "jl exception_underflow")?;
            }
            Instruction::Output => {
                write_tab!(file, "; --- Output ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "mov edi, [array + ebx * 8] ; edi = array[pointer]")?;
                write_tab!(file, "call putchar ; putchar(edi)")?;
            }
            Instruction::Input => {
                write_tab!(file, "; --- Input ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "call getchar ; eax = getchar()")?;
                write_tab!(file, "mov [array + ebx * 8], eax ; array[pointer] = eax")?;
            }
            Instruction::IncrementValue(value) => {
                write_tab!(file, "; --- Increment value ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "mov eax, [array + ebx * 8] ; eax = array[pointer]")?;
                write_tab!(file, "add eax, {value} ; eax += {value}")?;
                write_tab!(file, "cmp eax, 255")?;
                write_tab!(file, "jg .clear")?;
                write_tab!(file, "jmp .end")?;
                writeln!(file, ".clear:")?;
                write_tab!(file, "and eax, 255 ; eax &= 255")?;
                writeln!(file, ".end:")?;
                write_tab!(file, "mov [array + ebx * 8], eax ; array[pointer] = eax")?;
            }
            Instruction::DecrementValue(value) => {
                write_tab!(file, "; --- Decrement value ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "mov eax, [array + ebx * 8] ; eax = array[pointer]")?;
                write_tab!(file, "sub eax, {value} ; eax -= {value}")?;
                write_tab!(file, "test eax, eax")?;
                write_tab!(file, "js .clear")?;
                write_tab!(file, "jmp .end")?;
                writeln!(file, ".clear:")?;
                write_tab!(file, "and eax, 255 ; eax &= 255")?;
                writeln!(file, ".end:")?;
                write_tab!(file, "mov [array + ebx * 8], eax ; array[pointer] = eax")?;
            }
            Instruction::LoopStart {
                target: Some(target),
                ..
            } => {
                write_tab!(file, "; --- Loop start ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "mov eax, [array + ebx * 8] ; eax = array[pointer]")?;
                write_tab!(file, "cmp eax, 0")?;
                write_tab!(file, "je addr_{target}")?;
            }
            Instruction::LoopEnd {
                target: Some(target),
                ..
            } => {
                write_tab!(file, "; --- Loop end ---")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "mov eax, [array + ebx * 8] ; eax = array[pointer]")?;
                write_tab!(file, "cmp eax, 0")?;
                write_tab!(file, "jne addr_{target}")?;
            }
            Instruction::Debug => {
                write_tab!(file, "; --- Debug ---")?;
                write_tab!(file, "lea edi, [debug_pointer]")?;
                write_tab!(file, "mov esi, ebx")?;
                write_tab!(file, "xor eax, eax")?;
                write_tab!(file, "call printf")?;
                write_tab!(file, "xor eax, eax")?;
                write_tab!(file, "mov ebx, [pointer] ; ebx = pointer")?;
                write_tab!(file, "mov esi, [array + ebx * 8] ; eax = array[pointer]")?;
                write_tab!(file, "lea edi, [debug_memory]")?;
                write_tab!(file, "xor eax, eax")?;
                write_tab!(file, "call printf")?;
            }
            Instruction::LoopStart { .. } | Instruction::LoopEnd { .. } => {
                unreachable!("LoopStart and LoopEnd should have a target");
            }
        }
    }
    Ok(())
}

fn generate_yasm_x86_64_linux_footer(file: &mut File) -> Result<()> {
    write_tab!(file, "; --- EXIT ---")?;
    write_tab!(file, "mov edi, 0")?;
    write_tab!(file, "call exit")?;
    writeln!(file, "exception_overflow:")?;
    write_tab!(file, "mov edi, overflow_message")?;
    write_tab!(file, "xor eax, eax")?;
    write_tab!(file, "call printf")?;
    write_tab!(file, "mov edi, 1")?;
    write_tab!(file, "call exit")?;
    writeln!(file, "exception_underflow:")?;
    write_tab!(file, "mov edi, underflow_message")?;
    write_tab!(file, "xor eax, eax")?;
    write_tab!(file, "call printf")?;
    write_tab!(file, "mov edi, 1")?;
    write_tab!(file, "call exit")?;
    Ok(())
}

pub fn yasm_x86_64_linux_compiler(instructions: &[Instruction], output_file: &Path) -> Result<()> {
    let mut file = File::create("/tmp/out.s")?;
    generate_yasm_x86_64_linux_header(&mut file)?;
    generate_yasm_x86_64_linux_code(instructions, &mut file)?;
    generate_yasm_x86_64_linux_footer(&mut file)?;
    let output = Command::new("yasm")
        .args(["-f", "elf64", "-o", "/tmp/out.o", "/tmp/out.s"])
        .output();
    match output {
        Ok(output) => {
            if !output.status.success() {
                return Err(anyhow!(
                    "yasm failed with exit code {}\n{}",
                    output.status.code().expect("Invalid exit code"),
                    String::from_utf8_lossy(&output.stderr)
                ));
            }
            let path_str = output_file.to_str().expect("Invalid path");
            let output = Command::new("ld")
                .args([
                    "--dynamic-linker",
                    "/lib64/ld-linux-x86-64.so.2",
                    "-o",
                    path_str,
                    "-lc",
                    "/tmp/out.o",
                ])
                .output();
            match output {
                Ok(output) => {
                    if !output.status.success() {
                        return Err(anyhow!(
                            "ld failed with exit code {}\n{}",
                            output.status.code().expect("Invalid exit code"),
                            String::from_utf8_lossy(&output.stderr)
                        ));
                    }
                }
                Err(error) => return Err(anyhow!("ld failed with error: {}", error)),
            }
            Ok(())
        }
        Err(error) => Err(anyhow!("yasm failed with error: {}", error)),
    }
}

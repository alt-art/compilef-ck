use crate::parsing::Instruction;

use anyhow::{anyhow, Result};

use std::fs::File;
use std::io::Write;
use std::process::Command;

fn generate_yasm_x86_64_header(file: &mut File) -> Result<()> {
    writeln!(file, "; This file was generated by the Brainfuck compiler")?;
    writeln!(file, "; --- yasm-x86_64-compiler ---")?;
    writeln!(file, "; --- HEADER ---")?;
    writeln!(file, "extern exit")?;
    writeln!(file, "extern putchar")?;
    writeln!(file, "extern getchar")?;
    writeln!(file, "segment .data")?;
    writeln!(file, "\tarray: times 30000 dq 0")?;
    writeln!(file, "segment .text")?;
    writeln!(file, "\tglobal _start")?;
    writeln!(file, "_start:")?;
    writeln!(file, "\tmov rbp, 0")?;
    Ok(())
}

fn generate_yasm_x86_64_code(instructions: &[Instruction], file: &mut File) -> Result<()> {
    writeln!(file, "; --- BODY ---")?;
    for (index, instruction) in instructions.iter().enumerate() {
        writeln!(file, "addr_{}:", index)?;
        match instruction {
            Instruction::IncrementPointer => {
                writeln!(file, "\t; --- Increment pointer ---")?;
                writeln!(file, "\tadd rbp, 1 ; rbp += 1")?;
            }
            Instruction::DecrementPointer => {
                writeln!(file, "\t; --- Decrement pointer ---")?;
                writeln!(file, "\tsub rbp, 1 ; rbp -= 1")?;
            }
            Instruction::Output => {
                writeln!(file, "\t; --- Output ---")?;
                writeln!(file, "\tmov rdi, [array + rbp * 8] ; rdi = array[rbp]")?;
                writeln!(file, "\tcall putchar ; putchar(rdi)")?;
            }
            Instruction::Input => {
                writeln!(file, "\t; --- Input ---")?;
                writeln!(file, "\tcall getchar ; rax = getchar()")?;
                writeln!(file, "\tmov [array + rbp * 8], rax ; array[rbp] = rax")?;
            }
            Instruction::IncrementValue => {
                writeln!(file, "\t; --- Increment value ---")?;
                writeln!(file, "\tmov rax, [array + rbp * 8] ; rax = array[rbp]")?;
                writeln!(file, "\tadd rax, 1 ; rax += 1")?;
                writeln!(file, "\tmov [array + rbp * 8], rax ; array[rbp] = rax")?;
            }
            Instruction::DecrementValue => {
                writeln!(file, "\t; --- Decrement value ---")?;
                writeln!(file, "\tmov rax, [array + rbp * 8] ; rax = array[rbp]")?;
                writeln!(file, "\tsub rax, 1 ; rax -= 1")?;
                writeln!(file, "\tmov [array + rbp * 8], rax ; array[rbp] = rax")?;
            }
            Instruction::LoopStart(target) => {
                writeln!(file, "\t; --- Loop start ---")?;
                writeln!(file, "\tmov rax, [array + rbp * 8] ; rax = array[rbp]")?;
                writeln!(file, "\tcmp rax, 0")?;
                writeln!(file, "\tje addr_{}", target)?;
            }
            Instruction::LoopEnd(target) => {
                writeln!(file, "\t; --- Loop end ---")?;
                writeln!(file, "\tmov rax, [array + rbp * 8] ; rax = array[rbp]")?;
                writeln!(file, "\tcmp rax, 0")?;
                writeln!(file, "\tjne addr_{}", target)?;
            }
        }
    }
    Ok(())
}

fn generate_yasm_x86_64_footer(file: &mut File) -> Result<()> {
    writeln!(file, "\t; --- EXIT ---")?;
    writeln!(file, "\tmov rdi, 0")?;
    writeln!(file, "\tcall exit")?;
    Ok(())
}

pub fn yasm_x86_64_compiler(instructions: &[Instruction]) -> Result<()> {
    let mut file = File::create("/tmp/out.s")?;
    generate_yasm_x86_64_header(&mut file)?;
    generate_yasm_x86_64_code(instructions, &mut file)?;
    generate_yasm_x86_64_footer(&mut file)?;
    let output = Command::new("yasm")
        .args(&["-f", "elf64", "-o", "/tmp/out.o", "/tmp/out.s"])
        .output();
    match output {
        Ok(output) => {
            if !output.status.success() {
                return Err(anyhow!(
                    "yasm failed with exit code {}\n{}",
                    output.status.code().unwrap(),
                    String::from_utf8_lossy(&output.stderr)
                ));
            }
            let path = std::env::current_dir()?.join("out");
            let path_str = path.to_str().unwrap();
            let output = Command::new("ld")
                .args(&[
                    "--dynamic-linker",
                    "/lib64/ld-linux-x86-64.so.2",
                    "-o",
                    path_str,
                    "-lc",
                    "/tmp/out.o",
                ])
                .output();
            match output {
                Ok(output) => {
                    if !output.status.success() {
                        return Err(anyhow!(
                            "ld failed with exit code {}\n{}",
                            output.status.code().unwrap(),
                            String::from_utf8_lossy(&output.stderr)
                        ));
                    }
                }
                Err(error) => return Err(anyhow!("ld failed with error: {}", error)),
            }
            Ok(())
        }
        Err(error) => return Err(anyhow!("yasm failed with error: {}", error)),
    }
}

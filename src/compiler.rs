use crate::parsing::Instruction;
use crate::TargetPlatform;

use anyhow::{anyhow, Result};

use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;

macro_rules! write_tab {
    ($dst:expr, $($arg:tt)*) => {
        writeln!($dst, "\t{}", format!($($arg)*))
    };
}

fn printf_f_macro(file: &mut File, target: &TargetPlatform) -> Result<()> {
    writeln!(file, "%macro _printf_f 2")?;
    match target {
        TargetPlatform::Linux => {
            write_tab!(file, "lea rdi, [rel %1]")?;
            write_tab!(file, "mov rsi, %2")?;
        },
        TargetPlatform::Windows => {
            write_tab!(file, "lea rcx, [rel %1]")?;
            write_tab!(file, "mov rdx, %2")?;
        }
    }
    write_tab!(file, "xor rax, rax")?;
    write_tab!(file, "call printf")?;
    writeln!(file, "%endmacro")?;
    Ok(())
}

fn printf_s_macro(file: &mut File, target: &TargetPlatform) -> Result<()> {
    writeln!(file, "%macro _printf_s 1")?;
    match target {
        TargetPlatform::Linux => {
            write_tab!(file, "lea rdi, [rel %1]")?;
        },
        TargetPlatform::Windows => {
            write_tab!(file, "lea rcx, [rel %1]")?;
        }
    }
    write_tab!(file, "xor rax, rax")?;
    write_tab!(file, "call printf")?;
    writeln!(file, "%endmacro")?;
    Ok(())
}

fn putchar_macro(file: &mut File, target: &TargetPlatform) -> Result<()> {
    writeln!(file, "%macro _putchar 1")?;
    match target {
        TargetPlatform::Linux => {
            write_tab!(file, "mov rdi, %1")?;
        },
        TargetPlatform::Windows => {
            write_tab!(file, "mov rcx, %1")?;
        }
    }
    write_tab!(file, "xor rax, rax")?;
    write_tab!(file, "call putchar")?;
    writeln!(file, "%endmacro")?;
    Ok(())
}

fn exit_macro(file: &mut File, target: &TargetPlatform) -> Result<()> {
    writeln!(file, "%macro _exit 1")?;
    match target {
        TargetPlatform::Linux => {
            write_tab!(file, "mov rdi, %1")?;
        },
        TargetPlatform::Windows => {
            write_tab!(file, "mov rcx, %1")?;
        }
    }
    write_tab!(file, "call exit")?;
    writeln!(file, "%endmacro")?;
    Ok(())
}

fn generate_yasm_x86_64_linux_header(file: &mut File, target: &TargetPlatform) -> Result<()> {
    writeln!(file, "; This file was generated by the Brainfuck compiler")?;
    writeln!(file, "; --- yasm-x86_64-compiler ---")?;
    writeln!(file, "; --- HEADER ---")?;
    printf_f_macro(file, target)?;
    printf_s_macro(file, target)?;
    putchar_macro(file, target)?;
    exit_macro(file, target)?;
    writeln!(file, "extern exit")?;
    writeln!(file, "extern putchar")?;
    writeln!(file, "extern getchar")?;
    writeln!(file, "extern printf")?;
    writeln!(file, "segment .rodata")?;
    write_tab!(
        file,
        "\tdebug_pointer: db 10, \"--- DEBUG ---\", 10, \"pointer: %ld\", 10, 0"
    )?;
    write_tab!(
        file,
        "\tdebug_memory: db \"memory: %ld\", 10, \"--- DEBUG ---\", 10, 0"
    )?;
    write_tab!(
        file,
        "overflow_message: db 27, \"[1;31mERROR: overflow exception\", 27, \"[0m\", 10, 0"
    )?;
    write_tab!(
        file,
        "underflow_message: db 27, \"[1;31mERROR: underflow exception\", 27, \"[0m\", 10, 0"
    )?;
    writeln!(file, "segment .data")?;
    write_tab!(file, "pointer: dq 15000")?;
    writeln!(file, "segment .bss")?;
    write_tab!(file, "array: resb 240000")?;
    writeln!(file, "segment .text")?;
    write_tab!(file, "global main")?;
    writeln!(file, "main:")?;
    write_tab!(file, "lea rbp, [rel array]; rbp = array")?;
    Ok(())
}

fn generate_yasm_x86_64_linux_code(instructions: &[Instruction], file: &mut File) -> Result<()> {
    writeln!(file, "; --- BODY ---")?;
    for (index, instruction) in instructions.iter().enumerate() {
        writeln!(file, "addr_{index}:")?;
        match instruction {
            Instruction::IncrementPointer(value) => {
                write_tab!(file, "; --- Increment pointer ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "add rbx, {value} ; rbx += {value}")?;
                write_tab!(file, "mov [rel pointer], rbx ; pointer = rbx")?;
                write_tab!(file, "cmp rbx, 30000")?;
                write_tab!(file, "jge exception_overflow")?;
            }
            Instruction::DecrementPointer(value) => {
                write_tab!(file, "; --- Decrement pointer ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "sub rbx, {value} ; rbx -= {value}")?;
                write_tab!(file, "mov [rel pointer], rbx ; pointer = rbx")?;
                write_tab!(file, "cmp rbx, 0")?;
                write_tab!(file, "jl exception_underflow")?;
            }
            Instruction::Output => {
                write_tab!(file, "; --- Output ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "_putchar [rbp + rbx * 8] ; putchar(array[pointer])")?;
            }
            Instruction::Input => {
                write_tab!(file, "; --- Input ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "call getchar ; rax = getchar()")?;
                write_tab!(file, "mov [rbp + rbx * 8], rax ; array[pointer] = rax")?;
            }
            Instruction::IncrementValue(value) => {
                write_tab!(file, "; --- Increment value ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "mov rax, [rbp + rbx * 8] ; rax = array[pointer]")?;
                write_tab!(file, "add rax, {value} ; rax += {value}")?;
                write_tab!(file, "cmp rax, 255")?;
                write_tab!(file, "jg .clear")?;
                write_tab!(file, "jmp .end")?;
                writeln!(file, ".clear:")?;
                write_tab!(file, "and rax, 255 ; rax &= 255")?;
                writeln!(file, ".end:")?;
                write_tab!(file, "mov [rbp + rbx * 8], rax ; array[pointer] = rax")?;
            }
            Instruction::DecrementValue(value) => {
                write_tab!(file, "; --- Decrement value ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "mov rax, [rbp + rbx * 8] ; rax = array[pointer]")?;
                write_tab!(file, "sub rax, {value} ; rax -= {value}")?;
                write_tab!(file, "test rax, rax")?;
                write_tab!(file, "js .clear")?;
                write_tab!(file, "jmp .end")?;
                writeln!(file, ".clear:")?;
                write_tab!(file, "and rax, 255 ; rax &= 255")?;
                writeln!(file, ".end:")?;
                write_tab!(file, "mov [rbp + rbx * 8], rax ; array[pointer] = rax")?;
            }
            Instruction::LoopStart {
                target: Some(target),
                ..
            } => {
                write_tab!(file, "; --- Loop start ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "mov rax, [rbp + rbx * 8] ; rax = array[pointer]")?;
                write_tab!(file, "cmp rax, 0")?;
                write_tab!(file, "je addr_{target}")?;
            }
            Instruction::LoopEnd {
                target: Some(target),
                ..
            } => {
                write_tab!(file, "; --- Loop end ---")?;
                write_tab!(file, "mov rbx, [rel pointer] ; rbx = pointer")?;
                write_tab!(file, "mov rax, [rbp + rbx * 8] ; rax = array[pointer]")?;
                write_tab!(file, "cmp rax, 0")?;
                write_tab!(file, "jne addr_{target}")?;
            }
            Instruction::Debug => {
                write_tab!(file, "; --- Debug ---")?;
                write_tab!(file, "_printf_f debug_pointer, [rel pointer]")?;
                write_tab!(file, "_printf_f debug_memory, [rbp + rbx * 8]")?;
            }
            Instruction::LoopStart { .. } | Instruction::LoopEnd { .. } => {
                unreachable!("LoopStart and LoopEnd should have a target");
            }
        }
    }
    Ok(())
}

fn generate_yasm_x86_64_linux_footer(file: &mut File) -> Result<()> {
    write_tab!(file, "; --- EXIT ---")?;
    write_tab!(file, "_exit 0")?;
    writeln!(file, "exception_overflow:")?;
    write_tab!(file, "_printf_s overflow_message")?;
    write_tab!(file, "_exit 1")?;
    writeln!(file, "exception_underflow:")?;
    write_tab!(file, "_printf_s underflow_message")?;
    write_tab!(file, "_exit 1")?;
    Ok(())
}

pub fn yasm_x86_64_linux_compiler(
    instructions: &[Instruction],
    output_file: &Path,
    target: &TargetPlatform,
) -> Result<()> {
    let mut file = File::create("/tmp/out.s")?;
    generate_yasm_x86_64_linux_header(&mut file, target)?;
    generate_yasm_x86_64_linux_code(instructions, &mut file)?;
    generate_yasm_x86_64_linux_footer(&mut file)?;
    match target {
        TargetPlatform::Linux => target_linux_compile(output_file)?,
        TargetPlatform::Windows => target_windows_compile(output_file)?,
    };
    Ok(())
}

fn target_linux_compile(output_file: &Path) -> Result<()> {
    let output = Command::new("yasm")
        .arg("-f")
        .arg("elf64")
        .arg("-o")
        .arg("/tmp/out.o")
        .arg("/tmp/out.s")
        .output()?;
    if !output.status.success() {
        println!("{}", String::from_utf8(output.stderr)?);
        return Err(anyhow!(
            "yasm exited with status code {}",
            output.status.code().unwrap()
        ));
    }
    let output = Command::new("ld")
        .arg("--dynamic-linker")
        .arg("/lib64/ld-linux-x86-64.so.2")
        .arg("-o")
        .arg(output_file)
        .arg("-lc")
        .arg("/tmp/out.o")
        .output()?;
    if !output.status.success() {
        return Err(anyhow!(
            "ld exited with status code {}",
            output.status.code().unwrap()
        ));
    }
    Ok(())
}

fn target_windows_compile(output_file: &Path) -> Result<()> {
    let output = Command::new("yasm")
        .args(["-f", "win64"])
        .args(["-o", "/tmp/out.obj"])
        .arg("/tmp/out.s")
        .output()?;
    if !output.status.success() {
        eprintln!("{}", String::from_utf8(output.stderr)?);
        return Err(anyhow!(
            "yasm exited with status code {}",
            output.status.code().unwrap()
        ));
    }
    let output = Command::new("x86_64-w64-mingw32-ld")
        .arg("-s")
        .arg("-o")
        .arg(output_file)
        .arg("/tmp/out.obj")
        .args(["-l", "msvcrt"])
        .args(["-e", "main"])
        .output()?;
    if !output.status.success() {
        eprintln!("{}", String::from_utf8(output.stderr)?);
        return Err(anyhow!(
            "ld exited with status code {}",
            output.status.code().unwrap()
        ));
    }
    Ok(())
}
